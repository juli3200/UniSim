# this script was partially generated by GPT-4 and GPT-5

import numpy as np
from PyQt5.QtWidgets import QApplication, QFileDialog, QSlider
import pyqtgraph as pg # type: ignore
from pyqtgraph.Qt import QtWidgets, QtCore, QtGui  # type: ignore
import sys
import extract
import math

LIGANDS = True
LSIZE = 5

def get_fps(fps):
    for factor in range(1, 80):
        if 40<= fps*factor <= 80:
            return fps*factor
        
    return fps



class EntityCanvas(QtWidgets.QWidget):
    """A small widget that only draws the entity (the canvas part)."""
    def __init__(self, entity: extract.Entity):
        super().__init__()
        self.entity = entity
        self.setMinimumSize(300, 300)

    def update_entity(self, entity: extract.Entity):
        self.entity = entity
        self.update()

    def paintEvent(self, event):
        painter = QtGui.QPainter(self)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)

        # Background
        painter.fillRect(self.rect(), self.palette().brush(QtGui.QPalette.Window))

        if not self.entity:
            return

        # Draw entity as a circle
        center_x = self.width() / 2
        center_y = self.height() / 2
        radius = self.width() / 2

        painter.setBrush(QtGui.QBrush(QtCore.Qt.black))
        painter.setPen(QtGui.QPen(QtCore.Qt.black, 2))
        painter.drawEllipse(QtCore.QPointF(center_x, center_y), radius, radius)

        # Points on circumference
        angles_deg = getattr(self.entity, "received_ligands", [])

        if angles_deg:
            point_radius = 4  # radius of the little dot to draw
            painter.setBrush(QtGui.QBrush(QtCore.Qt.red))
            painter.setPen(QtGui.QPen(QtCore.Qt.black, 1))

            for deg in angles_deg:
                try:
                    a = float(deg)
                except Exception:
                    continue  # skip non-numeric entries

                # convert degrees to radians (Qt coordinate: +x right, +y down)
                rad = math.radians(a)

                # compute point on circumference
                x = center_x + (radius - point_radius - 1) * math.cos(rad)
                y = center_y + (radius - point_radius - 1) * math.sin(rad)

                # draw small filled circle for the point
                painter.drawEllipse(QtCore.QPointF(x, y), point_radius, point_radius)



        painter.end()


class VisualizeEntity(QtWidgets.QWidget):
    """A composite widget that contains the entity canvas and text labels."""
    def __init__(self, entity: extract.Entity, n_proteins):
        super().__init__()
        self.entity = entity
        self.init_ui(n_proteins)

    def init_ui(self, n_proteins):
        # Create layout
        layout = QtWidgets.QVBoxLayout(self)

        # Canvas on top
        self.canvas = EntityCanvas(self.entity)
        layout.addWidget(self.canvas, alignment=QtCore.Qt.AlignCenter)

        # Labels below
        self.name_label = QtWidgets.QLabel()
        self.size_label = QtWidgets.QLabel()
        self.energy_label = QtWidgets.QLabel()
        # Concentration levels label
        self.conc_label = QtWidgets.QLabel("Concentration Levels")
        layout.addWidget(self.conc_label)

        # Concentration levels values
        self.conc_values = QtWidgets.QLabel()

        # Add concentration levels to the horizontal layout
        horizontal_layout = QtWidgets.QHBoxLayout()
        self.conc_labels = []
        for i, level in enumerate(getattr(self.entity, "inner_protein_levels", [])):
            self.conc_labels.append(QtWidgets.QLabel(f"P{i}: {level}"))
            horizontal_layout.addWidget(self.conc_labels[i])

        # Sub-layout for labels
        label_layout = QtWidgets.QVBoxLayout()
        label_layout.addWidget(self.name_label)
        label_layout.addWidget(self.size_label)
        label_layout.addWidget(self.energy_label)
        layout.addWidget(self.conc_values)
        
        layout.addLayout(label_layout)
        layout.addLayout(horizontal_layout)

        self.update_labels()

    def update_labels(self):
        if not self.entity:
            return
        self.name_label.setText(f"Id: {getattr(self.entity, 'id', 'Unknown')}")
        self.size_label.setText(f"Size: {self.entity.size:.2f}")
        self.energy_label.setText(f"Energy: {getattr(self.entity, 'energy', 0):.2f}")
        for i, label in enumerate(self.conc_labels):
            label.setText(f"P{i}: {getattr(self.entity, 'inner_protein_levels', [])[i] if i < len(getattr(self.entity, 'inner_protein_levels', [])) else 0}")


    def update_entity(self, entity: extract.Entity):
        if not entity:
            return
        self.entity = entity
        self.canvas.update_entity(entity)
        self.update_labels()


class RealTimePlotter(QtWidgets.QWidget):
    def __init__(self, parent: QtWidgets.QWidget, world: extract.World):
        super().__init__()
        self.parent = parent
        self.world = world

        self.zoom = 1

        self.fps = world.fps
        self.dimx = world.dimx
        self.dimy = world.dimy
        self.plot_fps = get_fps(world.fps)
        print("Plot FPS:", self.plot_fps)
        self.update_interval = self.plot_fps / self.fps
        self.counter = 0


        self.clicked_on = None

        self.entities = []


        # Initialize PyQtGraph plot
        self.plot_widget = pg.PlotWidget()
        # Add grid to the plot
        self.plot_widget.showGrid(x=True, y=True)
        self.layout = QtWidgets.QVBoxLayout()
        self.layout.addWidget(self.plot_widget)
        self.setLayout(self.layout)


            

        # Set plot background to white
        self.plot_widget.setBackground(None)

        # Configure plot
        self.plot_widget.setXRange(0, self.dimx, padding=0)
        self.plot_widget.setYRange(0, self.dimy, padding=0)
        # Disable zoom and pan
        self.plot_widget.setMouseEnabled(x=False, y=False)

        # Store plot items
        self.points_e_plot = pg.ScatterPlotItem(pxMode=False)
        self.points_l_plot = pg.ScatterPlotItem(pxMode=False)


        # highlight item for clicked entity (transparent fill, colored outline)
        self.highlight_plot = pg.ScatterPlotItem(pxMode=False)
        self.highlight_plot.setBrush(pg.mkBrush(0,0,0,0))
        self.highlight_plot.setPen(pg.mkPen(255,0,0, width=2))
        self.plot_widget.addItem(self.highlight_plot)


        # Add plot items to the plot widget
        self.plot_widget.addItem(self.points_e_plot)
        self.plot_widget.addItem(self.points_l_plot)


        # Initialize timer for updates
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(int(1000/self.plot_fps / 2))  # 20 FPS
    
        # connect mouse click on the plot to handler
        self.plot_widget.scene().sigMouseClicked.connect(self.on_click)

    # GPT 5 generated
    def on_click(self, event):
        """Handle mouse click on plot, find nearest entity and print its id."""
        # map scene position to plot coordinates
        pos = event.scenePos()
        vb = self.plot_widget.plotItem.vb
        view_pos = vb.mapSceneToView(pos)
        x_click = view_pos.x()
        y_click = view_pos.y()

        if not hasattr(self, "entities") or len(self.entities) == 0:
            # clear selection
            self.clicked_on = None
            self.highlight_plot.clear()
            self.info_label.hide()
            return

        closest = None
        closest_dist2 = float("inf")
        for e in self.entities:
            dx = e.x - x_click
            dy = e.y - y_click
            dist2 = dx*dx + dy*dy
            size = getattr(e, "size", 1.0)
            threshold2 = max((size * 2.0) ** 2, 9.0)  # squared threshold (min radius 3)
            if dist2 <= threshold2 and dist2 < closest_dist2:
                closest_dist2 = dist2
                closest = e

        if closest is not None:
            eid = getattr(closest, "id", None)
            print(f"Clicked entity id: {eid}")
            self.clicked_on = eid
        else:
            # clicked empty space => clear selection
            self.clicked_on = None

    

    def update_plot(self):
        if self.counter % self.update_interval == 0:
            self.state = self.world.get_state()
            self.entities = self.state.entities
            self.ligands = self.state.ligands




        self.points_e_plot.setData(
            x = [e.x for e in self.entities],
            y = [e.y for e in self.entities],
            symbol='o',
            brush=[pg.mkBrush(0,0,0) for _ in self.entities],
            size=[e.size * 2  for e in self.entities]
        )

        if LIGANDS:
            self.points_l_plot.setData(
                x = [l.x for l in self.ligands],
                y = [l.y for l in self.ligands],
                symbol='o',
                brush=[pg.mkBrush(255,0,0) for _ in self.ligands],
                size=[0.1 * LSIZE for _ in self.ligands]
            )

        self.counter += 1

        # update highlight + info box if an entity is selected
        if getattr(self, "clicked_on", None) is not None:
            ent = next((e for e in self.entities if e.id == self.clicked_on), None)
            if ent is not None:
                self.highlight_plot.setData(
                    x=[ent.x],
                    y=[ent.y],
                    size=[max(ent.size * 2 + 4, 8)],
                    brush=[pg.mkBrush(0,0,0,0)],
                    pen=[pg.mkPen(255,0,0, width=2)],
                )
                # update and show info label
                self.parent.show_info(ent)
            else:
                # selected id not present anymore
                self.clicked_on = None
                self.highlight_plot.clear()
                self.parent.hide_info()
        else:
            self.highlight_plot.clear()
            self.parent.hide_info()



        
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, world: extract.World):
        super().__init__()

        self.setWindowTitle("UniSim")

        ratio = world.dimy / world.dimx
        self.original_size = QtCore.QSize(800, int(800 * ratio) + 50)
        self.resize(self.original_size)

        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)
        layout = QtWidgets.QVBoxLayout(central_widget)

        self.pauseButton = QtWidgets.QPushButton("Pause")
        self.pauseButton.setCheckable(True)
        self.pauseButton.clicked.connect(self.toggle_pause)
        layout.addWidget(self.pauseButton)

        self.real_time_plotter = RealTimePlotter(self,  world)
        
        layout.addWidget(self.real_time_plotter)

        # Create a horizontal layout to place the plotter and info box side by side
        horizontal_layout = QtWidgets.QHBoxLayout()
        layout.addLayout(horizontal_layout)

        # Add the real-time plotter to the left side
        horizontal_layout.addWidget(self.real_time_plotter)

        # Create an info box to display entity details
        self.info_label = VisualizeEntity(None, len(world.get_state(0).entities[0].inner_protein_levels) if world.get_state(0).entities else 0)
        self.info_label.hide()  # Initially hidden
        horizontal_layout.addWidget(self.info_label)

        self.info_shown = False


    def show_info(self, entity: extract.Entity):
        """Show the info box with details of the given entity."""
        if not entity:
            return
                  
        self.info_label.update_entity(entity)

        if self.info_shown:
            return

        self.info_label.show()

        # resize window to fit info box
        self.resize(self.width() + self.info_label.width(), self.height())

        self.info_shown = True

    def hide_info(self):
        """Hide the info box."""
        if not self.info_shown:
            return

        self.info_label.hide()

        # resize window to remove info box
        self.resize(self.original_size)

        self.info_shown = False
        
    def toggle_pause(self):
        """Toggle the paused state of the real-time plotter."""
        if self.pauseButton.isChecked():
            self.pauseButton.setText("Resume")
            self.real_time_plotter.timer.stop()
        else:
            self.pauseButton.setText("Pause")
            self.real_time_plotter.timer.start(int(1000 / self.real_time_plotter.plot_fps))

        


if __name__ == "__main__":
    app = QApplication([])
    file_dialog = QFileDialog()
    file_path, _ = file_dialog.getOpenFileName(None, "Select Binary File", "", "Binary Files (*.bin)")

    del app, file_dialog

    if not file_path:
        print("No file selected")
        exit()

    world = extract.World(file_path)

    print(world.fps, world.dimx, world.dimy, world.entity_bytes_0, world.store_capacity)
    

    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow(world)
    window.show()
    sys.exit(app.exec())
